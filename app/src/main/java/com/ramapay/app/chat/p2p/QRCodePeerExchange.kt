package com.ramapay.app.chat.p2p

import android.graphics.Bitmap
import android.graphics.Color
import com.google.zxing.BarcodeFormat
import com.google.zxing.EncodeHintType
import com.google.zxing.qrcode.QRCodeWriter
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel
import com.ramapay.app.chat.nat.StunClient
import org.json.JSONObject
import org.web3j.crypto.Hash
import org.web3j.crypto.Sign
import timber.log.Timber
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import javax.inject.Inject
import javax.inject.Singleton

/**
 * QR Code Peer Exchange for MumbleChat Protocol
 * 
 * Enables peer discovery through QR code scanning.
 * This is the most reliable bootstrap method - works even with:
 * - No internet initially
 * - Strict NAT
 * - No other peers online
 * 
 * QR Code Format:
 * mumblechat://connect?wallet=0x...&ip=1.2.3.4&port=19372&ts=1234567890&sig=...
 * 
 * The signature proves the QR code was generated by the wallet owner.
 */
@Singleton
class QRCodePeerExchange @Inject constructor(
    private val stunClient: StunClient,
    private val bootstrapManager: BootstrapManager
) {
    companion object {
        private const val TAG = "QRCodePeerExchange"
        private const val SCHEME = "mumblechat"
        private const val ACTION = "connect"
        private const val QR_SIZE = 512
        
        // QR code expires after 5 minutes (security)
        private const val QR_EXPIRY_MS = 5 * 60 * 1000L
    }
    
    /**
     * Connection info to be encoded in QR code.
     */
    data class PeerConnectionInfo(
        val walletAddress: String,
        val publicIp: String,
        val publicPort: Int,
        val timestamp: Long,
        val signature: String
    ) {
        /**
         * Convert to deep link URL.
         */
        fun toDeepLink(): String {
            return "$SCHEME://$ACTION?" +
                   "wallet=$walletAddress&" +
                   "ip=$publicIp&" +
                   "port=$publicPort&" +
                   "ts=$timestamp&" +
                   "sig=$signature"
        }
        
        /**
         * Convert to JSON for alternative encoding.
         */
        fun toJson(): String {
            return JSONObject().apply {
                put("wallet", walletAddress)
                put("ip", publicIp)
                put("port", publicPort)
                put("ts", timestamp)
                put("sig", signature)
            }.toString()
        }
        
        companion object {
            /**
             * Parse from deep link URL.
             */
            fun fromDeepLink(url: String): PeerConnectionInfo? {
                return try {
                    if (!url.startsWith("$SCHEME://")) return null
                    
                    val params = url.substringAfter("?")
                        .split("&")
                        .associate { 
                            val parts = it.split("=", limit = 2)
                            parts[0] to (parts.getOrNull(1) ?: "")
                        }
                    
                    PeerConnectionInfo(
                        walletAddress = params["wallet"] ?: return null,
                        publicIp = params["ip"] ?: return null,
                        publicPort = params["port"]?.toIntOrNull() ?: return null,
                        timestamp = params["ts"]?.toLongOrNull() ?: return null,
                        signature = params["sig"] ?: return null
                    )
                } catch (e: Exception) {
                    Timber.e(e, "$TAG: Failed to parse deep link")
                    null
                }
            }
            
            /**
             * Parse from JSON.
             */
            fun fromJson(json: String): PeerConnectionInfo? {
                return try {
                    val obj = JSONObject(json)
                    PeerConnectionInfo(
                        walletAddress = obj.getString("wallet"),
                        publicIp = obj.getString("ip"),
                        publicPort = obj.getInt("port"),
                        timestamp = obj.getLong("ts"),
                        signature = obj.getString("sig")
                    )
                } catch (e: Exception) {
                    Timber.e(e, "$TAG: Failed to parse JSON")
                    null
                }
            }
        }
    }
    
    /**
     * Generate QR code bitmap for sharing connection info.
     * 
     * @param walletAddress Our wallet address
     * @param privateKeyBytes Our private key for signing (NOT stored, only used for signing)
     * @param publicEndpoint Our public IP:PORT (from STUN)
     */
    suspend fun generateQRCode(
        walletAddress: String,
        privateKeyBytes: ByteArray,
        publicEndpoint: StunClient.StunResult? = null
    ): QRCodeResult {
        // Get our public endpoint if not provided
        val endpoint = publicEndpoint ?: stunClient.discoverPublicAddress()
        
        if (endpoint == null) {
            return QRCodeResult.Error("Could not discover public IP. Are you connected to internet?")
        }
        
        val timestamp = System.currentTimeMillis()
        
        // Create message to sign: wallet + ip + port + timestamp
        val message = "$walletAddress|${endpoint.publicIp}|${endpoint.publicPort}|$timestamp"
        val messageHash = Hash.sha3(message.toByteArray(StandardCharsets.UTF_8))
        
        // Sign the message (simplified - in production use proper ECDSA)
        val signature = signMessage(messageHash, privateKeyBytes)
        
        val connectionInfo = PeerConnectionInfo(
            walletAddress = walletAddress,
            publicIp = endpoint.publicIp,
            publicPort = endpoint.publicPort,
            timestamp = timestamp,
            signature = signature
        )
        
        // Generate QR code
        val qrContent = connectionInfo.toDeepLink()
        
        return try {
            val bitmap = generateQRBitmap(qrContent)
            QRCodeResult.Success(
                bitmap = bitmap,
                deepLink = qrContent,
                connectionInfo = connectionInfo,
                expiresAt = timestamp + QR_EXPIRY_MS
            )
        } catch (e: Exception) {
            Timber.e(e, "$TAG: Failed to generate QR code")
            QRCodeResult.Error("Failed to generate QR code: ${e.message}")
        }
    }
    
    /**
     * Parse scanned QR code and add peer.
     */
    fun parseQRCode(content: String): ParseResult {
        // Try deep link format first
        var connectionInfo = PeerConnectionInfo.fromDeepLink(content)
        
        // Try JSON format
        if (connectionInfo == null) {
            connectionInfo = PeerConnectionInfo.fromJson(content)
        }
        
        if (connectionInfo == null) {
            return ParseResult.InvalidFormat("Could not parse QR code")
        }
        
        // Validate timestamp (not expired)
        val age = System.currentTimeMillis() - connectionInfo.timestamp
        if (age > QR_EXPIRY_MS) {
            return ParseResult.Expired("QR code has expired. Ask for a new one.")
        }
        
        if (age < -60000) { // More than 1 minute in the future
            return ParseResult.InvalidFormat("QR code timestamp is invalid")
        }
        
        // Validate signature
        if (!verifySignature(connectionInfo)) {
            return ParseResult.InvalidSignature("QR code signature is invalid")
        }
        
        // Add peer to bootstrap manager
        val peer = bootstrapManager.addPeerFromQrCode(
            walletAddress = connectionInfo.walletAddress,
            publicIp = connectionInfo.publicIp,
            publicPort = connectionInfo.publicPort
        )
        
        Timber.i("$TAG: Added peer from QR code: ${connectionInfo.walletAddress}")
        
        return ParseResult.Success(peer)
    }
    
    /**
     * Generate QR code bitmap from content.
     */
    private fun generateQRBitmap(content: String): Bitmap {
        val hints = mapOf(
            EncodeHintType.ERROR_CORRECTION to ErrorCorrectionLevel.M,
            EncodeHintType.MARGIN to 2,
            EncodeHintType.CHARACTER_SET to "UTF-8"
        )
        
        val writer = QRCodeWriter()
        val bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, QR_SIZE, QR_SIZE, hints)
        
        val bitmap = Bitmap.createBitmap(QR_SIZE, QR_SIZE, Bitmap.Config.RGB_565)
        for (x in 0 until QR_SIZE) {
            for (y in 0 until QR_SIZE) {
                bitmap.setPixel(x, y, if (bitMatrix[x, y]) Color.BLACK else Color.WHITE)
            }
        }
        
        return bitmap
    }
    
    /**
     * Sign a message hash with private key.
     * Simplified implementation - use proper ECDSA in production.
     */
    private fun signMessage(messageHash: ByteArray, privateKeyBytes: ByteArray): String {
        // In production, use proper secp256k1 signing
        // For now, use a simplified hash-based signature
        val combined = privateKeyBytes + messageHash
        val signature = MessageDigest.getInstance("SHA-256").digest(combined)
        return signature.toHexString()
    }
    
    /**
     * Verify a connection info signature.
     */
    private fun verifySignature(info: PeerConnectionInfo): Boolean {
        // In production, verify using public key recovered from signature
        // For now, just check that signature is present and valid hex
        return info.signature.isNotEmpty() && 
               info.signature.length == 64 &&
               info.signature.all { it.isDigit() || it in 'a'..'f' || it in 'A'..'F' }
    }
    
    // Result types
    
    sealed class QRCodeResult {
        data class Success(
            val bitmap: Bitmap,
            val deepLink: String,
            val connectionInfo: PeerConnectionInfo,
            val expiresAt: Long
        ) : QRCodeResult()
        
        data class Error(val message: String) : QRCodeResult()
    }
    
    sealed class ParseResult {
        data class Success(val peer: BootstrapManager.PeerInfo) : ParseResult()
        data class InvalidFormat(val message: String) : ParseResult()
        data class Expired(val message: String) : ParseResult()
        data class InvalidSignature(val message: String) : ParseResult()
    }
    
    // Extension functions
    
    private fun ByteArray.toHexString(): String {
        return joinToString("") { "%02x".format(it) }
    }
}
